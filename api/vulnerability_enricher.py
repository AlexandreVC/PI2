"""
Vulnerability Enricher Module.

Automatically enriches AI-detected vulnerabilities with:
- Related CWEs from official MITRE CWE database (semantic search)
- Related CVEs from NVD (via CWE mapping + semantic similarity)
- MITRE ATT&CK techniques and tactics
- Severity estimation based on similar vulnerabilities
"""

import re
import logging
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from collections import Counter
import math

# Import CWE client for semantic matching
from api.cwe_client import get_cwe_database, CWEMatch

logger = logging.getLogger(__name__)


@dataclass
class CWEMatchResult:
    """Result of CWE matching with confidence."""
    cwe_id: str
    name: str
    score: float
    match_reasons: List[str]


@dataclass
class EnrichmentResult:
    """Result of vulnerability enrichment."""
    original_vulnerability: Dict[str, Any]
    matched_cwes: List[str]
    cwe_matches: List[CWEMatchResult]  # Detailed CWE matches with confidence
    related_cves: List[Dict[str, Any]]
    mitre_techniques: List[Dict[str, Any]]
    mitre_tactics: List[str]
    estimated_severity: str
    estimated_cvss: float
    confidence_score: float


# ============================================
# Vulnerability Type to CWE Mapping
# ============================================
VULN_TYPE_TO_CWE = {
    # Injection vulnerabilities
    "sql injection": ["CWE-89", "CWE-564"],
    "sqli": ["CWE-89"],
    "command injection": ["CWE-78", "CWE-77"],
    "os command injection": ["CWE-78"],
    "code injection": ["CWE-94", "CWE-95"],
    "ldap injection": ["CWE-90"],
    "xpath injection": ["CWE-91"],
    "xml injection": ["CWE-91"],
    "nosql injection": ["CWE-943"],

    # XSS vulnerabilities
    "xss": ["CWE-79"],
    "cross-site scripting": ["CWE-79"],
    "reflected xss": ["CWE-79"],
    "stored xss": ["CWE-79"],
    "dom xss": ["CWE-79"],

    # Authentication/Authorization
    "broken authentication": ["CWE-287", "CWE-306"],
    "authentication bypass": ["CWE-287"],
    "broken access control": ["CWE-284", "CWE-862"],
    "insecure direct object reference": ["CWE-639"],
    "idor": ["CWE-639"],
    "privilege escalation": ["CWE-269"],
    "missing authorization": ["CWE-862"],

    # Cryptographic issues
    "weak cryptography": ["CWE-327", "CWE-328"],
    "insecure crypto": ["CWE-327"],
    "weak hashing": ["CWE-328", "CWE-916"],
    "md5": ["CWE-328"],
    "sha1": ["CWE-328"],
    "hardcoded credentials": ["CWE-798", "CWE-259"],
    "hardcoded password": ["CWE-259"],
    "hardcoded secret": ["CWE-798"],
    "sensitive data exposure": ["CWE-200", "CWE-312"],

    # Input validation
    "path traversal": ["CWE-22", "CWE-23"],
    "directory traversal": ["CWE-22"],
    "lfi": ["CWE-98"],
    "rfi": ["CWE-98"],
    "file inclusion": ["CWE-98"],
    "unvalidated redirect": ["CWE-601"],
    "open redirect": ["CWE-601"],
    "ssrf": ["CWE-918"],
    "server-side request forgery": ["CWE-918"],

    # Deserialization
    "insecure deserialization": ["CWE-502"],
    "unsafe deserialization": ["CWE-502"],
    "pickle": ["CWE-502"],
    "yaml load": ["CWE-502"],

    # Information disclosure
    "information disclosure": ["CWE-200"],
    "information leakage": ["CWE-200"],
    "error message disclosure": ["CWE-209"],
    "stack trace": ["CWE-209"],
    "debug mode": ["CWE-489"],

    # Memory safety
    "buffer overflow": ["CWE-120", "CWE-119"],
    "heap overflow": ["CWE-122"],
    "stack overflow": ["CWE-121"],
    "use after free": ["CWE-416"],
    "memory leak": ["CWE-401"],
    "null pointer": ["CWE-476"],

    # Other
    "csrf": ["CWE-352"],
    "cross-site request forgery": ["CWE-352"],
    "xxe": ["CWE-611"],
    "xml external entity": ["CWE-611"],
    "race condition": ["CWE-362"],
    "denial of service": ["CWE-400"],
    "dos": ["CWE-400"],
    "regex dos": ["CWE-1333"],
    "prototype pollution": ["CWE-1321"],
}


# ============================================
# Vulnerability Type to MITRE ATT&CK Mapping
# ============================================
VULN_TYPE_TO_MITRE = {
    # Injection -> Execution, Initial Access
    "sql injection": {
        "techniques": ["T1190", "T1059"],
        "tactics": ["Initial Access", "Execution"]
    },
    "command injection": {
        "techniques": ["T1059", "T1203"],
        "tactics": ["Execution"]
    },
    "code injection": {
        "techniques": ["T1055", "T1059"],
        "tactics": ["Execution", "Defense Evasion"]
    },

    # XSS -> Initial Access, Collection
    "xss": {
        "techniques": ["T1189", "T1185"],
        "tactics": ["Initial Access", "Collection"]
    },
    "cross-site scripting": {
        "techniques": ["T1189", "T1185"],
        "tactics": ["Initial Access", "Collection"]
    },

    # Auth issues -> Credential Access, Privilege Escalation
    "broken authentication": {
        "techniques": ["T1078", "T1110"],
        "tactics": ["Credential Access", "Initial Access"]
    },
    "authentication bypass": {
        "techniques": ["T1078"],
        "tactics": ["Initial Access", "Defense Evasion"]
    },
    "privilege escalation": {
        "techniques": ["T1068", "T1548"],
        "tactics": ["Privilege Escalation"]
    },
    "hardcoded credentials": {
        "techniques": ["T1552", "T1078"],
        "tactics": ["Credential Access"]
    },

    # Crypto -> Credential Access
    "weak cryptography": {
        "techniques": ["T1600", "T1557"],
        "tactics": ["Credential Access", "Collection"]
    },

    # File/Path issues -> Collection, Exfiltration
    "path traversal": {
        "techniques": ["T1083", "T1005"],
        "tactics": ["Discovery", "Collection"]
    },
    "file inclusion": {
        "techniques": ["T1059", "T1105"],
        "tactics": ["Execution", "Command and Control"]
    },

    # SSRF -> Initial Access, Lateral Movement
    "ssrf": {
        "techniques": ["T1090", "T1021"],
        "tactics": ["Command and Control", "Lateral Movement"]
    },

    # Deserialization -> Execution
    "insecure deserialization": {
        "techniques": ["T1059", "T1203"],
        "tactics": ["Execution"]
    },

    # Info disclosure -> Discovery, Collection
    "information disclosure": {
        "techniques": ["T1082", "T1083"],
        "tactics": ["Discovery"]
    },

    # XXE -> Collection, Exfiltration
    "xxe": {
        "techniques": ["T1005", "T1041"],
        "tactics": ["Collection", "Exfiltration"]
    },
}


class VulnerabilityEnricher:
    """
    Enriches vulnerabilities with CVE, CWE, and MITRE ATT&CK data.

    Uses semantic similarity search against the official CWE database
    for accurate CWE matching.
    """

    def __init__(self, nvd_client=None, mitre_client=None):
        """
        Initialize the enricher.

        Args:
            nvd_client: NVDClient instance for CVE lookups
            mitre_client: MITREClient instance for technique lookups
        """
        self.nvd_client = nvd_client
        self.mitre_client = mitre_client
        self._cve_cache = {}
        self._technique_cache = {}

        # Initialize CWE database for semantic search
        try:
            self.cwe_database = get_cwe_database()
            logger.info(f"CWE database initialized with {len(self.cwe_database.cwes)} entries")
        except Exception as e:
            logger.warning(f"Failed to initialize CWE database: {e}")
            self.cwe_database = None

    def enrich_vulnerability(self, vulnerability: Dict[str, Any]) -> EnrichmentResult:
        """
        Enrich a single vulnerability with related data.

        Args:
            vulnerability: Vulnerability dict from AI scanner

        Returns:
            EnrichmentResult with all enriched data
        """
        # Extract vulnerability info
        vuln_type = vulnerability.get("vulnerability_type", "")
        vuln_name = vulnerability.get("name", vulnerability.get("title", ""))
        description = vulnerability.get("description", "")
        code_snippet = vulnerability.get("code_snippet", vulnerability.get("vulnerable_code", ""))

        # Normalize vulnerability type
        vuln_type_normalized = self._normalize_vuln_type(vuln_type, vuln_name, description)

        # Get CWE mappings using semantic search
        cwe_matches, matched_cwes = self._get_cwes_semantic(
            vuln_type_normalized,
            description,
            code_snippet
        )

        # Get related CVEs
        related_cves = self._find_related_cves(
            vuln_type_normalized,
            matched_cwes,
            description
        )

        # Get MITRE ATT&CK data
        mitre_techniques, mitre_tactics = self._get_mitre_mapping(vuln_type_normalized)

        # Estimate severity
        estimated_severity, estimated_cvss = self._estimate_severity(
            vuln_type_normalized,
            related_cves,
            vulnerability.get("severity", "")
        )

        # Calculate confidence score (now includes CWE match quality)
        confidence = self._calculate_confidence(
            cwe_matches,
            related_cves,
            mitre_techniques
        )

        return EnrichmentResult(
            original_vulnerability=vulnerability,
            matched_cwes=matched_cwes,
            cwe_matches=cwe_matches,
            related_cves=related_cves[:5],  # Top 5 related CVEs
            mitre_techniques=mitre_techniques,
            mitre_tactics=mitre_tactics,
            estimated_severity=estimated_severity,
            estimated_cvss=estimated_cvss,
            confidence_score=confidence
        )

    def enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[EnrichmentResult]:
        """Enrich multiple vulnerabilities."""
        return [self.enrich_vulnerability(v) for v in vulnerabilities]

    def _normalize_vuln_type(self, vuln_type: str, name: str, description: str) -> str:
        """Normalize vulnerability type for mapping lookups."""
        # Combine all text sources
        combined = f"{vuln_type} {name} {description}".lower()

        # Check for known vulnerability patterns
        patterns = {
            r"sql\s*inject": "sql injection",
            r"command\s*inject": "command injection",
            r"os\s*command": "command injection",
            r"xss|cross.site.script": "xss",
            r"path\s*travers|directory\s*travers": "path traversal",
            r"hardcoded\s*(credential|password|secret|key)": "hardcoded credentials",
            r"weak\s*(crypto|hash|cipher)": "weak cryptography",
            r"md5|sha1": "weak cryptography",
            r"deseriali[sz]": "insecure deserialization",
            r"pickle|yaml\.load|eval\(": "insecure deserialization",
            r"ssrf|server.side.request": "ssrf",
            r"xxe|xml.external": "xxe",
            r"csrf|cross.site.request.forg": "csrf",
            r"auth(entication)?\s*bypass": "authentication bypass",
            r"broken\s*auth": "broken authentication",
            r"privile?ge\s*escal": "privilege escalation",
            r"info(rmation)?\s*(disclos|leak)": "information disclosure",
            r"debug\s*mode|debug.?true": "debug mode",
            r"buffer\s*overflow": "buffer overflow",
            r"code\s*inject": "code injection",
            r"ldap\s*inject": "ldap injection",
            r"open\s*redirect|unvalidated\s*redirect": "open redirect",
            r"file\s*inclus|[lr]fi": "file inclusion",
        }

        for pattern, vuln_type_name in patterns.items():
            if re.search(pattern, combined):
                return vuln_type_name

        # Return original if no pattern matches
        return vuln_type.lower() if vuln_type else "unknown"

    def _get_cwes_semantic(
        self,
        vuln_type: str,
        description: str,
        code_snippet: str = ""
    ) -> Tuple[List[CWEMatchResult], List[str]]:
        """
        Get CWE IDs using semantic similarity search.

        Uses TF-IDF based similarity against the official CWE database
        for accurate matching.

        Args:
            vuln_type: Normalized vulnerability type
            description: Vulnerability description
            code_snippet: Optional vulnerable code

        Returns:
            Tuple of (detailed matches, list of CWE IDs)
        """
        cwe_matches = []
        cwe_ids = []

        # Try semantic search first
        if self.cwe_database:
            try:
                matches = self.cwe_database.find_matching_cwes(
                    vuln_type=vuln_type,
                    description=description,
                    code_snippet=code_snippet,
                    max_results=5,
                    min_score=0.15
                )

                for match in matches:
                    cwe_matches.append(CWEMatchResult(
                        cwe_id=match.cwe.cwe_id,
                        name=match.cwe.name,
                        score=match.score,
                        match_reasons=match.match_reasons
                    ))
                    cwe_ids.append(match.cwe.cwe_id)

                if cwe_matches:
                    logger.info(f"CWE semantic search found {len(cwe_matches)} matches for '{vuln_type}'")
                    logger.info(f"Best match: {cwe_matches[0].cwe_id} ({cwe_matches[0].name}) with score {cwe_matches[0].score:.2f}")
                    return cwe_matches, cwe_ids

            except Exception as e:
                logger.warning(f"CWE semantic search failed: {e}")

        # Fallback to static mapping
        return self._get_cwes_static(vuln_type)

    def _get_cwes_static(self, vuln_type: str) -> Tuple[List[CWEMatchResult], List[str]]:
        """Fallback to static CWE mapping."""
        cwe_ids = []

        # Direct lookup
        if vuln_type in VULN_TYPE_TO_CWE:
            cwe_ids = VULN_TYPE_TO_CWE[vuln_type]
        else:
            # Fuzzy match
            for key, cwes in VULN_TYPE_TO_CWE.items():
                if key in vuln_type or vuln_type in key:
                    cwe_ids = cwes
                    break

        # Convert to CWEMatchResult with lower confidence
        cwe_matches = [
            CWEMatchResult(
                cwe_id=cwe_id,
                name="",  # No name in static mapping
                score=0.6,  # Lower confidence for static mapping
                match_reasons=["Static mapping (fallback)"]
            )
            for cwe_id in cwe_ids
        ]

        return cwe_matches, cwe_ids

    def _get_cwes(self, vuln_type: str) -> List[str]:
        """Get CWE IDs for a vulnerability type (legacy method)."""
        _, cwe_ids = self._get_cwes_semantic(vuln_type, "", "")
        return cwe_ids

    def _find_related_cves(
        self,
        vuln_type: str,
        cwes: List[str],
        description: str
    ) -> List[Dict[str, Any]]:
        """Find related CVEs using CWE mapping and semantic similarity."""
        related_cves = []

        if not self.nvd_client:
            return related_cves

        try:
            # Method 1: Search by CWE
            for cwe in cwes[:2]:  # Limit to first 2 CWEs
                cwe_id = cwe.replace("CWE-", "")
                cves = self.nvd_client.fetch_cves_by_keyword(f"CWE-{cwe_id}")
                for cve in cves[:3]:  # Top 3 per CWE
                    parsed = self.nvd_client.parse_cve_to_vulnerability(cve)
                    parsed["match_reason"] = f"CWE match: {cwe}"
                    related_cves.append(parsed)

            # Method 2: Keyword search based on vulnerability type
            keywords = self._extract_keywords(vuln_type, description)
            if keywords:
                keyword_str = " ".join(keywords[:3])
                cves = self.nvd_client.fetch_cves_by_keyword(keyword_str)
                for cve in cves[:5]:
                    parsed = self.nvd_client.parse_cve_to_vulnerability(cve)
                    parsed["match_reason"] = f"Keyword match: {keyword_str}"
                    # Check if not already added
                    if not any(c.get("id") == parsed.get("id") for c in related_cves):
                        related_cves.append(parsed)

            # Sort by CVSS score (descending) and recency
            related_cves.sort(
                key=lambda x: (x.get("cvss_score", 0), x.get("id", "")),
                reverse=True
            )

        except Exception as e:
            logger.warning(f"Error finding related CVEs: {e}")

        return related_cves

    def _extract_keywords(self, vuln_type: str, description: str) -> List[str]:
        """Extract search keywords from vulnerability info."""
        # Common vulnerability keywords
        keywords = []

        # Add vulnerability type keywords
        if vuln_type:
            keywords.extend(vuln_type.split())

        # Extract important terms from description
        if description:
            # Remove common words
            stopwords = {
                "the", "a", "an", "is", "are", "was", "were", "be", "been",
                "being", "have", "has", "had", "do", "does", "did", "will",
                "would", "could", "should", "may", "might", "must", "shall",
                "can", "to", "of", "in", "for", "on", "with", "at", "by",
                "from", "as", "into", "through", "during", "before", "after",
                "above", "below", "between", "under", "again", "further",
                "then", "once", "here", "there", "when", "where", "why",
                "how", "all", "each", "few", "more", "most", "other", "some",
                "such", "no", "nor", "not", "only", "own", "same", "so",
                "than", "too", "very", "just", "this", "that", "these", "those"
            }

            words = re.findall(r'\b[a-z]{3,}\b', description.lower())
            important_words = [w for w in words if w not in stopwords]

            # Count frequency
            word_counts = Counter(important_words)
            keywords.extend([word for word, _ in word_counts.most_common(5)])

        return list(set(keywords))

    def _get_mitre_mapping(self, vuln_type: str) -> Tuple[List[Dict], List[str]]:
        """Get MITRE ATT&CK techniques and tactics for a vulnerability type."""
        techniques = []
        tactics = set()

        # Direct lookup
        mapping = VULN_TYPE_TO_MITRE.get(vuln_type)

        if not mapping:
            # Fuzzy match
            for key, value in VULN_TYPE_TO_MITRE.items():
                if key in vuln_type or vuln_type in key:
                    mapping = value
                    break

        if mapping:
            technique_ids = mapping.get("techniques", [])
            tactics.update(mapping.get("tactics", []))

            # Get full technique details if MITRE client available
            if self.mitre_client:
                for tech_id in technique_ids:
                    tech = self.mitre_client.get_technique_by_id(tech_id)
                    if tech:
                        techniques.append(tech)
                    else:
                        # Fallback to basic info
                        techniques.append({
                            "id": tech_id,
                            "name": f"Technique {tech_id}",
                            "url": f"https://attack.mitre.org/techniques/{tech_id}/"
                        })
            else:
                # No client, return basic info
                for tech_id in technique_ids:
                    techniques.append({
                        "id": tech_id,
                        "name": f"Technique {tech_id}",
                        "url": f"https://attack.mitre.org/techniques/{tech_id}/"
                    })

        return techniques, list(tactics)

    def _estimate_severity(
        self,
        vuln_type: str,
        related_cves: List[Dict],
        original_severity: str
    ) -> Tuple[str, float]:
        """Estimate severity based on related CVEs and vulnerability type."""

        # Default severity by vulnerability type
        severity_map = {
            "sql injection": ("CRITICAL", 9.0),
            "command injection": ("CRITICAL", 9.5),
            "code injection": ("CRITICAL", 9.0),
            "insecure deserialization": ("CRITICAL", 9.0),
            "xxe": ("HIGH", 8.0),
            "xss": ("HIGH", 7.0),
            "ssrf": ("HIGH", 8.0),
            "path traversal": ("HIGH", 7.5),
            "file inclusion": ("HIGH", 8.0),
            "authentication bypass": ("HIGH", 8.5),
            "broken authentication": ("HIGH", 8.0),
            "privilege escalation": ("HIGH", 8.0),
            "hardcoded credentials": ("HIGH", 7.5),
            "csrf": ("MEDIUM", 6.0),
            "open redirect": ("MEDIUM", 5.0),
            "weak cryptography": ("MEDIUM", 6.0),
            "information disclosure": ("MEDIUM", 5.0),
            "debug mode": ("MEDIUM", 5.5),
        }

        # Get default from map
        default_severity, default_cvss = severity_map.get(vuln_type, ("MEDIUM", 5.0))

        # If we have related CVEs, use their average CVSS
        if related_cves:
            cvss_scores = [
                cve.get("cvss_score", 0)
                for cve in related_cves
                if cve.get("cvss_score")
            ]
            if cvss_scores:
                avg_cvss = sum(cvss_scores) / len(cvss_scores)
                # Weight towards default if few samples
                weight = min(len(cvss_scores) / 5, 1.0)
                estimated_cvss = (avg_cvss * weight) + (default_cvss * (1 - weight))

                # Determine severity from CVSS
                if estimated_cvss >= 9.0:
                    return "CRITICAL", round(estimated_cvss, 1)
                elif estimated_cvss >= 7.0:
                    return "HIGH", round(estimated_cvss, 1)
                elif estimated_cvss >= 4.0:
                    return "MEDIUM", round(estimated_cvss, 1)
                else:
                    return "LOW", round(estimated_cvss, 1)

        return default_severity, default_cvss

    def _calculate_confidence(
        self,
        cwe_matches: List[CWEMatchResult],
        cves: List[Dict],
        techniques: List[Dict]
    ) -> float:
        """
        Calculate confidence score for the enrichment.

        Takes into account the quality of CWE semantic matches.
        """
        score = 0.0

        # CWE matching contributes 40% (increased because of semantic search)
        if cwe_matches:
            # Use best match score weighted by number of matches
            best_score = cwe_matches[0].score if cwe_matches else 0
            match_count_bonus = min(len(cwe_matches) / 3, 1.0) * 0.1
            cwe_score = (best_score * 0.3) + match_count_bonus
            score += cwe_score

        # CVE matches contribute 35%
        if cves:
            # More matches = higher confidence
            cve_score = min(len(cves) / 5, 1.0) * 0.35
            score += cve_score

        # MITRE mapping contributes 25%
        if techniques:
            score += 0.25

        return round(min(score, 1.0), 2)

    def to_enriched_vulnerability(self, result: EnrichmentResult) -> Dict[str, Any]:
        """Convert EnrichmentResult to enriched vulnerability dict."""
        vuln = result.original_vulnerability.copy()

        # Add enrichment data with detailed CWE matches
        vuln["enrichment"] = {
            "cwes": result.matched_cwes,
            "cwe_details": [
                {
                    "id": match.cwe_id,
                    "name": match.name,
                    "confidence": round(match.score, 2),
                    "match_reasons": match.match_reasons
                }
                for match in result.cwe_matches
            ],
            "related_cves": [
                {
                    "id": cve.get("id"),
                    "title": cve.get("title", "")[:100],
                    "cvss": cve.get("cvss_score"),
                    "severity": cve.get("severity"),
                    "match_reason": cve.get("match_reason", "")
                }
                for cve in result.related_cves
            ],
            "mitre_techniques": [
                {
                    "id": tech.get("id"),
                    "name": tech.get("name"),
                    "url": tech.get("url")
                }
                for tech in result.mitre_techniques
            ],
            "mitre_tactics": result.mitre_tactics,
            "confidence": result.confidence_score
        }

        # Update severity if we have a better estimate
        if result.estimated_cvss > 0:
            vuln["severity"] = result.estimated_severity
            vuln["cvss_score"] = result.estimated_cvss

        return vuln


# Singleton instance
_enricher: Optional[VulnerabilityEnricher] = None


def get_enricher(nvd_client=None, mitre_client=None) -> VulnerabilityEnricher:
    """Get or create the global enricher instance."""
    global _enricher
    if _enricher is None:
        _enricher = VulnerabilityEnricher(nvd_client, mitre_client)
    elif nvd_client or mitre_client:
        # Update clients if provided
        if nvd_client:
            _enricher.nvd_client = nvd_client
        if mitre_client:
            _enricher.mitre_client = mitre_client
    return _enricher
